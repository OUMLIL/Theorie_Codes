  0.0000000e+000  1.0000000e+000  5.0000000e+000  6.0000000e+000  1.4000000e+001  1.5000000e+001  2.7000000e+001  2.8000000e+001
  2.0000000e+000  4.0000000e+000  7.0000000e+000  1.3000000e+001  1.6000000e+001  2.6000000e+001  2.9000000e+001  4.2000000e+001
  3.0000000e+000  8.0000000e+000  1.2000000e+001  1.7000000e+001  2.5000000e+001  3.0000000e+001  4.1000000e+001  4.3000000e+001
  9.0000000e+000  1.1000000e+001  1.8000000e+001  2.4000000e+001  3.1000000e+001  4.0000000e+001  4.4000000e+001  5.3000000e+001
  1.0000000e+001  1.9000000e+001  2.3000000e+001  3.2000000e+001  3.9000000e+001  4.5000000e+001  5.2000000e+001  5.4000000e+001
  2.0000000e+001  2.2000000e+001  3.3000000e+001  3.8000000e+001  4.6000000e+001  5.1000000e+001  5.5000000e+001  6.0000000e+001
  2.1000000e+001  3.4000000e+001  3.7000000e+001  4.7000000e+001  5.0000000e+001  5.6000000e+001  5.9000000e+001  6.1000000e+001
  3.5000000e+001  3.6000000e+001  4.8000000e+001  4.9000000e+001  5.7000000e+001  5.8000000e+001  6.2000000e+001  6.3000000e+001


CImg<unsigned char> DCT(CImg<unsigned char> sub_image)
{
    // cimg_for_insideXY(sub_image,x ,y) {
    //      sub_image(x,y) -= 128;
    // }
    CImg<float> res(sub_image.width(),sub_image.height(),1,1,0);
    float dct=0;
    float somme=0;
    for(int i=0; i < res.height(); i++) {
        for(int j=0; j < res.width(); j++){
            for(int x=0; x<N; x++){
                for(int y=0; y<N;y++){
                    somme += sub_image(x,y) *cos((2*x+1)*i*M_PI/(2*8))*cos((2*y+1)*j*M_PI/(2*8));
                }
            }
            dct = (2/N)*(i>0?1:1/sqrt(2))*(j>0?1:1/sqrt(2))*somme;
            std::cout << dct << std::endl;
            res(i,j) = (2/N)*(i>0?1:1/sqrt(2))*(j>0?1:1/sqrt(2))*somme;
        }
    }
    return res;
}

CImg<unsigned char> JPEGEncoder(CImg<unsigned char> image, float quality)
{
    CImg<float> comp(image.width(),image.height(),1,1,0);

    int step = 8;
    for(int y=0; y < image.height(); y+=8) {
        for(int x=0; x < image.width(); x+=8){
            CImg<float> sub_image = image.get_crop(x,y,x+(step-1),y+(step-1));
            //sub_image=DCT(sub_image);
        }
    }
    // cimg_for_insideXY(comp,x ,y, 8) {
    //     //DCT
    //     std::cout << comp(x,y) << std::endl;
    // }

    comp = image; //to remove replace by JPEG process

 // Quantization matrix
/*
 CImg<> Q(8,8);
 Q(0,0)=16;   Q(0,1)=11;   Q(0,2)=10;   Q(0,3)=16;   Q(0,4)=24;   Q(0,5)=40;   Q(0,6)=51;   Q(0,7)=61;
 Q(1,0)=12;   Q(1,1)=12;   Q(1,2)=14;   Q(1,3)=19;   Q(1,4)=26;   Q(1,5)=58;   Q(1,6)=60;   Q(1,7)=55;
 Q(2,0)=14;   Q(2,1)=13;   Q(2,2)=16;   Q(2,3)=24;   Q(2,4)=40;   Q(2,5)=57;   Q(2,6)=69;   Q(2,7)=56;
 Q(3,0)=14;   Q(3,1)=17;   Q(3,2)=22;   Q(3,3)=29;   Q(3,4)=51;   Q(3,5)=87;   Q(3,6)=80;   Q(3,7)=62;
 Q(4,0)=18;   Q(4,1)=22;   Q(4,2)=37;   Q(4,3)=56;   Q(4,4)=68;   Q(4,5)=109;  Q(4,6)=103;  Q(4,7)=77;
 Q(5,0)=24;   Q(5,1)=35;   Q(5,2)=55;   Q(5,3)=64;   Q(5,4)=81;   Q(5,5)=104;  Q(5,6)=113;  Q(5,7)=92;
 Q(6,0)=49;   Q(6,1)=64;   Q(6,2)=78;   Q(6,3)=87;   Q(6,4)=103;  Q(6,5)=121;  Q(6,6)=120;  Q(6,7)=101;
 Q(7,0)=72;   Q(7,1)=92;   Q(7,2)=95;   Q(7,3)=98;   Q(7,4)=112;  Q(7,5)=100;  Q(7,6)=103;  Q(7,7)=99;
 Q *= quality; 
*/

 // TODO: code to insert

 return comp;
}